# 第二章 进程



##  2.1.1 进程的定义，组成，组织方式，特征

#### 进程的定义

- **程序段，数据段，PCB**三部分组成了**进程实体**。一般情况下，我们把**进程实体就简称为进程**。
- 所谓创建进程，实质上是**创建进程实体中的PCB**；而撤销进程，实质是撤销进程实体中的PCB。
- **ＰＣＢ是进程存在的唯一标志。**
- 从不同的角度，进程可以有不同的定义
  - 进程是程序的一次**执行过程**
  - 进程是程序及其数据在处理机上顺序**执行时所发生的活动**
  - 进程是具有独立功能的程序，在数据集合上**运行的过程**，他是系统进行资源分配和调度的一个独立单位。

- 引入进程实体的概念后,可把进程定义为:
  - 进程是**进程实体的运行过程**,是系统进行**资源分配和调度**的一个独立单位.

------

#### 进程的组成

- 进程由 **程序段,数据段,PCB**三个部分组成
- 程序段:代码存放的位置
- 数据段:程序运行时使用和产生的运算数据.
- **PCB：操作系统通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息．**
  - 进程描述信息
  - 进程控制和管理信息
  - 资源分配清单
  - 处理机相关信息

------

#### 进程的组织

##### 链接方式

- **按照进程状态将PCB分为多个队列**
- 操作系统持有指向各个队列的指针 (**就绪队列,阻塞队列,运行队列**,运行队列里只有一个进程,因为CPU同一时刻只为一个进程服务)

##### 索引方式

- **根据进程状态的不同建立几张索引表**
- **操作系统持有指向各个索引表的指针**

#### 进程的特征

- **动态性**:**动态性是进程最基本的特征**,进程是程序的一次执行过程,是动态地产生变化和消亡的

- **并发性**:内存中有多个进程实体,各进程可并发执行

- **独立性**: **进程是能独立运行,独立获得资源,独立接受调度的基本单位**

- **异步性**:**各进程按各自独立的,不可预知的速度向前推进**,操作系统要提供"进程同步机制"来解决异步问题. **异步性导致并发程序执行结果的不确定性.**

- **结构性**:每个进程会配置一个PCB，结构上看，进程由**程序段，数据段，PCB构成**

  

------



## 2.1.2进程的状态与转换

##### 状态

- 运行状态:进程得到CPU和其他资源
- 就绪状态:得到了其他资源但是未被CPU调用
- 阻塞状态:啥都没有
- 创建状态:操作为新进程分配资源,创建PCB
- 终止状态：操作系统回收进程的资源，撤销PCB

##### 转换

- 就绪态-运行态:进程被调度
- 运行态-就绪态:时间片用完,或CPU被其他优先级高的进程占用
- 运行态-阻塞态:等待系统资源分配,或等待某事件发生(主动行为)
- 阻塞态-就绪态:资源分配到位,等待事件的发生(被动行为)
- 创建态-就绪态:系统完成创建进程的相关工作
- 运行态-终止态:进程运行结束,或运行时遇到不可修复的错误

------

## 2.13 进程的控制

#### 什么是进程控制

- 进程控制的主要功能是： **对系统中的所有进程实施有效的管理**，他具有创建新进程，撤销已有进程，实现进程状态转换等功能。
- 总而言之：**进程控制就是要实现进程状态转换**



#### 如何实现进程控制？

- **原语**：用原语实现进程控制。
  - 特点：执行期间不允许中断，只能一气呵成。
  - 这种不可中断的操作**：原子操作**
  - 原语采用：“**关中断指令**”和“**开中断指令**”。
  - 原语是只允许在**核心态**下执行的**特权指令**

#### 进程控制相关的原语

- **进程创建,进程的终止,进程的阻塞,进程的唤醒,进程的切换**

- 无论哪个原语，执行时无非做三件事情
  - 1.**更新PCB中的信息**（如修改进程状态标志，将运行环境保存到PCB，从PCB恢复运行环境）
    - 所有的进程控制原语一定都会修改进程状态标志
    - 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
    - 将某进程开始运行前必要恢复运行环境
  - ２.**将PCB插入合适的队列**
  - **分配／回收资源**
- **创建原语:**无->创建态->就绪态.
  - 申请空白ＰＣＢ
  - 为新进程分配所需资源
  - 初始化PCB
  - 将PCB插入就绪队列
- **撤销原语:**
  - 从PCB集合中找到终止进程的PCB
  - 若进程正在运行,立即剥夺CPU,将CPU分配给其他进程
  - 终止其所有子进程
  - 将该进程拥有的所有资源归还给父进程或操作系统
  - 删除PCB
- **阻塞原语**
  - 找到要阻塞的进程对于的ＰＣＢ
  - 保护进程运行现场，将PCB　状态信息设置为＂阻塞态＂,暂时停止进程运行
  - 将PCB插入相应事件的等待队列
- **唤醒原语**:
  - 在事件等待队列中找到PCB
  - 将PCB从等待队列移除,设置进程为就绪态
  - 将PCB插入就绪队列,等待被调度
- **切换原语**
  - 将运行环境信息存入PCB
  - PCB移入相应队列
  - 选择另一个进程执行,并更新其PCB
  - 根据PCB恢复新进程所需的运行环境

## 2.1.4 进程通信

#### 什么是进程通信?

- 进程之间的信息交互.进程是分配系统的资源(包括内存地址空间),因此各进程拥有的内存地址空间相互独立
- **为了保证安全,一个进程不能直接访问另一个进程的地址空间**

##### 进程通信包括:共享存储,消息传递,管道通信

- **共享存储:**

  - 操作系统为进程分配一个共享空间.两个进程**访问共享空间是互斥的**.
  - 基于数据结构的共享:共享方式速度慢,限制多,是一种低级通信方式
  - 基于存储区的共享:在内存画出一块共享存储区,数据的形式,存放位置都由进程控制,而不是操作系统.相比之下,这种共享方式速度更快,更是一种高级通信方式.

- **管道通信**:

  **管道:是指用于连接读写进程的一个共享文件,又名pipe文件.其实就是在内存中开辟一个大小固定的缓冲区**.

  - **1.管道只能采用半双工通信,某一时间段内只能实现单向的传输.如果要实现双向同时通信,则需要设置两个管道.**
  - 2.各进程**互斥地**访问管道
  - 3.数据以字符流的形式写入管道,当**管道写满**时,**写进程的write()系统调用将被阻塞**,等待读进程将数据取走.当**读进程将数据全部取走**后,管道变空,此时读进程的**read()系统调用将被阻塞**.
  - **4.如果没写满,就不允许读.如果没读空,就不允许写.**
  - **数据一旦被读出,就从管道中被抛弃,就以为着读进程最多只能有一个,否则会有读错数据的情况.**

- **消息传递**

  - 进程间的数据交换以**格式化的消息**为单位.进程通过操作系统提供的**"发送消息/接受消息 "**两个**原语**进行数据交换.
  - **传递方式**
    - **直接通信方式**:消息直接挂到接收进程的消息缓冲队列上
    - **间接通信方式**:消息要先发送到中间实体中,因此也称"信箱通信方式".

****

## 2.1.5线程的概念和多线程模型

- 一个进程有多个线程
- 引入线程之后，**线程是一个基本的CPU执行单元**，也是**程序执行流的最小单位**。
- 各线程之间可以并发的执行，进一步的提升了系统的并发性
- 引入线程之后，进程只作为除CPU之外的系统资源分配单位

#### 引入线程机制后，有什么变化？

- **资源分配和调度的变化：**
  - 传统进程机制中，进程是资源分配和调度的基本单位。
  - 引入线程后，**进程是资源分配的基本单位，线程是调度的基本单位**
- **并发性的变化**
  - 传统的只能进程间并发
  - **各线程间也能并发，提升了并发度**
- **系统开销的变化**
  - 传统进程间并发，**需要切换进程的运行环境，系统开销很大**
  - 线程间并发，如果是**同一进程内的线程切换，则不需要切换进程环境，系统开销小**



------

#### 线程的属性

- **线程是处理机调度的单位**
- 多个CPU计算机中，各个进程可占用不同CPU
- **每个线程都有一个线程ID，线程控制块TCB**
- 线程也有就绪，阻塞，运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程的资源
- **由于共享内存地址空间，同一进程中的线程通信无需操作系统的干预**
- 同一进程的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统开销较大

------



#### 线程的实现方式

- **用户级线程**
  - 由应用程序通过线程库实现
  - 线程管理工作都由应用程序负责
  - 线程切换在用户态即可完成
  - **在用户看来是有多个线程。但是操作系统内核并不意识到线程的存在。**
- **内核级线程**
  - **内核级线程的管理工作由操作系统内核完成**
  - **线程调度，切换等工作由内核完成**，因此内核级线程的切换必须在**核心态**下才能完成
  - 即内核级线程是从操作系统内核视角看能看到的线程
- **二者组合的方式**
  - 在这种方式下，由于**操作系统只看得见内核级线程，因此内核级线程才是处理机分配的单**位

------

#### 多线程模型

- **多对一模型**：多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程
  - 优点：用户级线程的切换在用户空间完成，线程管理的系统开销小，效率高
  - 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行
- **一对一模型**：一个用户级对应一个内核级线程
  - 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行的执行。
  - 缺点：一个用户级进程占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。
- **多对多模型：n->m**
  - 优点:克服了前面两个的缺点



------

## 2.2.1处理机调度的概念，层次

#### 调度的基本概念

- 在多道程序中，进程的数量是多余处理机的个数的，这样不能同时并行地处理各个进程。**处理机调度，就是从就绪队列中，按照一定的算法选择一个进程并行将处理机分配给它运行，以实现进程的并发执行。**

#### 调度的三个层次

- **高级调度**(作业调度)：按照某种规则，**从后备队列中选择合适的作业将其调入内存，并为其创建进程**
- **中级调度**（内存调度）：**从挂起队列中选择合适的进程将其数据调回内存**
- **低级调度：**（进程调度）：按照某种规则，从**就绪队列中选择一个进程为其分配处理机**

------

## 2.2.2 进程调度的时机，切换过程，方式

### 进程调度的时机

- **进程调度**：按照某种算法从**就绪队列**中选择一个进程为其分配处理机
  - 需要进行进程调度与切换的情况
    - 当前运行的进程**主动放弃**处理机
      - **进程正常终止**
      - **运行过程中发生异常而终止**
      - **进程主动请求阻塞**
    - 当前运行的进程被动放弃处理机
      - **分给进程的时间片用完了**
      - **有更紧急的事情需要处理**
      - **有更高优先级的进程进入就绪队列**
- 有时候**不能进行进程的调度**
  - **在处理中断的过程中**：中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程调度
  - 在**操作系统内核 程序临界区**：
  - **原子操作过程**中：原子操作不可中断。
- **临界资源**：**一个时间段只允许一个进程使用的资源。各进程需要互斥地访问临界资源**
- **临界区**：**访问临界资源的那段代码**
- ***内核程序临界区一般是用来访问某种 内核数据结构的。比如进程的就绪队列 。***
  - **内核程序临界区访问的临界资源，如果不尽快释放的话，既有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度和切换**



### 进程调度的方式

- 非剥夺调度方式：又称非抢占方式。
- **剥夺调度方式：**当一个进程正在处理机上执行时，如果有一个更 重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要更紧迫的进程。

### 进程的切换与过程

- **狭义的进程调度：**指的是从就绪队列中选中一个要运行的进程。
- 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程
- **广义的进程调度**包含了选择一个进程和进程切换两个步骤。
  - **进程切换的过程主要完成了：对原来运行进程各种数据的保存和对新的进程各种数据的恢复。**
- **进程调度和切换是有代价的，不是调度越 频繁并发度就越高。**

------

## 2.2.3 调度算法的评价指标

- **CPU利用率** 
- **系统吞吐量**：单位时间内完成作业的数量
-  **周转时间**
  - 从作业被提交给系统开始，到作业完成为止的这段时间间隔
  - 四个部分
    - 作业在外存后备队列上等待作业调度的时间
    - 进程在就绪队列等待进程调度的时间
    - 进程在CPU上执行的时间
    - 进程等待I/o操作完成的时间
  - **作业周转时间=作业完成时间-作业提交时间**
  - **平均周转时间=各作业周转时间之和/作业数**
  - **带权周转时间=作业周转时间/作业实际运行的时间**
  - **平均带权周转时间=各作业带权周转时间之和/作业数**
-  **等待时间** ：处**于等待处理机状态时间之和。**
- **响应时间**：用户提交请求到首次产生响应的时间



------

## 2.2.4 调度算法

- 先来先服务
- 短作业优先
- 高响应比优先

#### 先来先服务

- 算法规则：**按照作业/进程到达的先后顺序进行服务**
- 用于作业/进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列
- **非抢占师算法**
- 优点：公平算法实现简单。 缺点：对于排在长作业后面的短作业需要等待很长时间



## 2.2.5 各种调度算法

------

## 2.3.1进程的同步和互斥



## 2.3.2 进程互斥的软件实现方法

- **单标志法**： 两个进程在**访问完临界区**后会把使用临界区的权限转交给另一个进程。也就是说 **每个进程进入临界区的权限只能被另一个进程赋予。**
  - 违背了“空闲让进”的原则
- **双标志先检查法**：设置一个布尔型数组flag[],数组中各个元素用来标志各进程想进入临界区的意愿
- **双标志后检查法：**